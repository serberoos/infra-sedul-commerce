[ 토폴로지 ]
(본사 토폴로지)
서버팜과 개발자의 서비스 개발 업무에 따른 프로세스를 맡은 송재근 입니다.

먼저 저희조의 토폴로지는 본사와 지사로 나누어지며 본사 부분의 서버팜을 제가 맡고 네트워크 엔터프라이즈 부분을 전혁님
DMZ 부분은 홍엽님, AAA, SNMP 서버를 구병근님, 

(지사 토폴로지)
본사와 지사간의 DMVPN 부분을 이연준님과, 김정아 님께서 맡으셨습니다.

저희는 먼저 각 맡은 부분에 대해 발표하고 만들어진 토폴로지에서의 각 프로세스 트래픽 시나리오를 설명드리도록 하겠습니다.
(본사 토폴로지에서 서버팜 부분을 가리키며)
그럼 다음으로 서버팜 부분을 말씀 드리겠습니다.

[ 서버 팜 ]
서버팜은 이름 처럼 서버들이 모여있는 서버실이라고 보시면 될 것 같은데,
존 베이스 파이어월 라우터를 경계로 L3 스위치를 지나 L2스위치에 서버들이 위치해 있습니다.
L2 스위치에서 L3스위치를 벗어나면 네트워크에 대해서 알지 못하므로 OSPF를 설정해주었으며 엔터프라이즈 네트워크와 연결됩니다.
엔터프라이즈 네트워크 부터 이중화가 되어 서버팜 부분까지 트래픽을 분산하기 위해 이더채널 설정을 해주었습니다.
보시면 특이점이 존 베이스 파이어월을 사용하는데 존베이스 파이어 월에 대해서 설명 드리겠습니다.

[ 존 베이스 파이어월 ]
라우터를 방화벽으로 사용하는 방법으로 라우터 인터페이스를 ZONE에 할당하고 존 그룹 사이에 보안 정책을 적용하는 방법입니다.
비용적으로 가장 저렴하게 방화벽을 구축할 수 있는 방법으로 원래 서버팜에도 소포스를 이용해보려고 했는데, UTM기능을 100퍼센트 활용하지 못할 것 같아
ZonebaseFW를 이용했습니다.

[ 존 베이스 파이어월 정책 ]
INSIDE1 INSIDE2 SERVER1 SERVER2로 Zone을 나누고 정책을 할당했습니다.
간단하게 INSIDE SERVER로 나누어 정책을 설명 드리자면 INSIDE에서 SERVER로 HTTP, HTTPS FTP 트래픽을 허용하고 SERVER쪽에서 INSIDE로 나갈때는 모든 트래픽을 허용 해주었습니다.

[ 개발자 서비스 개발 업무 ]
다음으로 토폴로지에서의 개발자 서비스 개발 업무에 대해 말씀드리겠습니다.
슬라이드에 왼쪽에 보시면 GITHUB JENKINS 도커 허브 등등 처음 보시는 용어가 많은데 개발업무에 대해서 설명 드리기 전에 용어 개념 설명을 먼저 해드리겠습니다.

[깃 허브]
깃허브에 대해서 설명 드리겠습니다.
깃허브는 개발자들 프로그래밍을 할 때, 만든 코드를 한곳에 올려두고 관리하기 위한 사이트입니다. 
프로젝트를 할때 여러 사람이서 코드를 만들어서 합쳐야 되잖아요. 합친 코드는 버전이 되는데, 깃허브에 합쳐서 버전관리를 하게 됩니다.

[도커]
도커는 저희가 실습에서 VMware를 사용해서 윈도우서버나 리눅스나 윈도우를 띄웠었는데, 이런 방식을 버츄얼 머신이라고 합니다.
슬라이드에서 한눈으로도 버츄얼 머신 보다 컨테이너가 슬림한데요.
vm과 container의 차이는
vm에서는 에는 호스트 운영체제 위에 하이퍼 바이저라는 가상화 툴이 올라가고 그 위에 각 VM에 대한 운영체제가 올라간뒤 어플리케이션이 올라가지만
container에서는 호스트 운영체제 위에 리눅스 기반의 경량화된 Docker Engine만 올라가 VM보다 슬림합니다.
container에 Docker Engine이 있잖아요 Docker란 컨테이너를 관리하는 프로그램 입니다.

정말 쉽게 말하면 도커도 VM입니다. 근데 좀더 가벼운 VM이라고 보시면 될 것 같습니다.

[도커 허브]
아까 Github가 개발자들이 코드를 올려두고 같이 협업을 하는 곳이라고 말씀드렸는데, 도커허브도 협업과 공유를 위해 도커를 관리하는 사이트 입니다.

쉽게 말해서 VM을 원할때 바로 다운로드 받아서 사용할 수 있도록 도커로 포장해서 올려두는 곳이라고 보시면 될 것 같습니다.

[젠킨스]
젠킨스는 아이콘이 딱 보시면 하인이잖아요? 얘는 쉽게 말해서 명령어를 대신 쳐주는 하인 프로그램입니다.
개발자가 프로그램을 만들고 서버를 실행할때도 명령어로 올리고 깃허브에서 데이터를 받아오는 것도 명령어로 수행하고 명령어가 정말 많이 들어가는데, 서버가 업데이트 될때마다 직접 계속 명령어를 쳐줘서 다시 켜줄수는 없기 때문에
젠킨스가 명령어적인 부분을 직접 쳐줍니다.

[깃 플로우] [ 프로그램 결과물 통합/배포 과정 ]
그럼 앞에서 설명 드린 개념을 기반으로 개발자의 개발 업무 파이프라인을 설명해드리겠습니다.
먼저 깃플로우에 대해서 설명드릴 필요가 있는데요.
아까 Github에 개발자들이 만든 코드를 합쳐서 관리한다고 말씀드렸는데, 깃플로우는 어떻게 합쳐서 관리하는가에 대한 방법론중의 하나입니다.
깃에는 브랜치라는게 있는데 깃의 기능에서 개발자들이 어떤 기능을 만들때 브랜치 라는 것을 만들고 코드를 만든후 각자의 브랜치를 합치는 방식으로 개발을 수행하게 됩니다. 

깃플로우 그림에 보시면
보시면 Master랑 Develop 브랜치 2개가 있는데, 쉽게 게임을 예로 들어서 말씀드리겠습니다.
게임에 보시면 테스트 서버랑 본서버가 있잖아요?
쉽게 말하면 Master 브랜치는 본서버
Develop브랜치는 테스트 서버로 말할 것 같습니다.

각 개발자들은 기능을 개발할때 Develop 브랜치에서 기능 브랜치를 따로 만들고 Develop(테스트 브랜치)와 합칩니다. 그리고 어느정도 기능이 개발되어서 본서버에 올릴 준비가 되면 코드를 Release 브랜치로 보내고 Master(본서버로) 합칩니다.
마찬가지로 Master브랜치에서 버그가 발생하면 hotfix 브랜치를 만들어서 해결하고 해결한 내용을 각각 master와 develop브랜치에 반영하는 걸 나타내는 그림입니다.

[프로그램 결과물 통합/배포과정]
그래서 저희는 이러한 깃플로우를 기반으로 다음처럼 프로그램 결과물 통합 배포과정을 설계했는데요.
개발자가 웹 어플리케이션을 깃허브로 PUSH 올리면 master 브랜치냐 develop 브랜치냐에 따라서 Github 홈페이지에서는 웹 훅이라는 걸 젠킨스로 보냅니다. 
(깃허브 홈페이지에가면 웹훅을 설정하는 부분이 있는데, 젠킨스쪽에도 깃허브 ip를 알려주고 깃허브쪽에도 젠킨스 ip를 알려줘서 연결하게 됩니다.

그럼 젠킨스에서는 깃허브에 통합된 코드를 받아서 Docker VM를 만들고 도커 허브로 PUSH 올려주면 master(본서버)브랜치에 푸쉬가 되었다면 본서버에 웹서버를 실행시키고 develop(테스트 서버) 브랜치에 푸쉬가 되었다면 테스트 서버에 웹서버를 실행시키게 됩니다.

그래서 이런 프로그램 결과물 통합/배포 과정을 통해서 원래 말씀드리려고 했던 저희 새둘 본사 토폴로지에서의 개발자 서비스 개발업무에 대해서 말씀드리겠습니다.
먼저 토폴로지에서 Serverfarm에 있는 부분은 개발자들이 개발을 하기 위한 테스트 서버 dmz에 있는 부분은 사용자들이 웹 페이지를 이용하기 위한 본서버입니다. 
개발자가 깃허브로 코드를 PUSH 하면 깃허브에서는 젠킨스로 코드 웹훅을 전달하고 젠킨스는 도커 VM 컨테이너를 빌드해 도커허브로 PUSH합니다.
마직막으로 master에 푸쉬되었나 develop에 푸쉬가 되었나에 따라서 (각 서버를 가리키며) 운영 서버에 배포가 되거나 테스트 서버에 배포를 수행합니다.

여기까지 서버팜과 개발자 서비스 개발 업무에 관련된 발표를 마치겠습니다.





